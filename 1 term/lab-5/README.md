### Лабораторна робота No 5

----
#### Комментарий:

У лабораторной работы 6 версий, первые 4 - путь к 5 и 6, поэтому их сдавать не нужно было. 5 и 6 в свою очередь как 2 различных финала одного фильма. Считаются они тоже отдельными лабораторными.
Помимо всего прочего, начиная с 5й версии этой лабораторной необходимо использовать функцию copyright, вынесенную в отдельную статическую библиотеку (sl-cr-000).
В документации к библиотеке написано как ее подключать и как ею пользоваться.

----
#### Умова: 
Протабулювати функції `f(x), S(x) ` та `S(x)-f(x)` на відрізку `[a; b]` з кроком `h`, де `a0<a`, `b<b0` та
`a0 = -0.9, b0 = 0.9, f(x) = ch x, S(x)= ∑(x^2n/(2n)!)` при `n = 0...+∞`

При обчисленні за значення `S(x)` прийняти першу часткову суму `Sn`, за якої `|Sn-Sn-1| < ε`.

Значення `a`, `b`, `h` та `ε` задає користувач.

----
#### Вимоги:
0. Див. Загальні вимоги.

1. У середовищі програмування створено проект, в який додано необхідні одиниці тран-
сляції з текстом програми. Програма успішно компілюється й будується виконуваний файл.

2. На початку роботи програми виводиться інформація щодо виконавця (за допомогою
функції з раніш розробленої статичної бібліотеки) та умова задачі.

3. Хід виконання програми відповідає такому алгоритму: повідомити інформацію щодо
виконавця та призначення програми, ввести вхідні дані, вивести задані вхідні дані та
табличку результатів або повідомити про некоректність вхідних даних. Відповідні частини
тексту програми розташовуються послідовно.

4. Значення змінних вводяться користувачем. Зокрема, користувач задає
    – значення a початку відрізку, на якому табулюється функція;

    – значення b кінця відрізку, на якому табулюється функція;

    – крок h з яким виконується табуляція функції;

    – значення ε, яке обумовлює точність обчислення;

    – у 4-му варіанті користувач також задає додатнє натуральне значення m.

5. Наявні зрозумілі підказки на введення даних.

6. Значення a0 і b0 «прошиті» в коді (наприклад, `const double a0=1000.0`;).

7. Наявні функції обчислення значень f(x) і S(x), які за допустимих значень
обчислюють ці значення правильно. Якщо в математичній бібліотеці наявна функція для
обчислення f(x), то власну функцію писати НЕ треба. Увага: функція для обчислення S(x)
приймає не тільки x, але й ε (а в 4-му варіанті ще й m).

8. Обчислення значення S(x) використовує рекурентні співвідношення та є якомога
економним за кількістю виконуваних обчислень.

9. За потреби (якщо сума збігається дуже-дуже повільно) обчислення S(x) дозволяється
додатково обмежити розглядом не більше, ніж N перших часткових сум Sn. Відповідне
значення варто оформити незмінюваною цілою локальною змінною функції обчислення S(x)
(hint: у тілі функції: `const int N=1000`;). Використання неіменованих числових констант для
позначення граничної кількості обчислених часткових сум слід уникати.

10. Програма НЕ використовує масиви та інші структури даних для зберігання
послідовностей значень.

11. Наявна функція, що за коректних значень a, b, h, ε (та m у 4-му варіанті) виконує
табуляцію функцій f(x), S(x) та S(x)-f(x) на відрізку [a; b] з кроком h. Табуляція полягає в
тому, що друкується табличка значень, а саме для кожної точки x=a, a+h, a+2h, ...,
a+[(b-a)/h]⋅h, а також для точки b (якщо вона відсутня в наведеному переліку), у окремому
рядку виводяться значення x, f(x), S(x) та S(x)-f(x).
Hint: зверніть увагу, щоб значення в останній точці проміжку не друкувалося двічі.
Символи псевдографіки для оформлення таблички можна не виводити, але стовпці
таблиці мають чітко проглядатися (hint: задавайте ширину поля виведення та притискайте
праворуч). Дійсні числа виводити у форматі з фіксованою крапкою з поміркованою
кількістю знаків після крапки; для значення S(x)-f(x) виводити не менше 6 знаків після
крапки.

12. Табуляція є економною за кількістю виконуваних викликів функцій, що обчислюють
f та S (ось тут f(x), S(x) та S(x)-f(x) чотири виклики, але достатньо двох).

13. Наявна функція, що друкує рядок із значеннями x, f(x), S(x) та S(x)-f(x).

14. У випадку некоректних вхідних даних табулювання не виконується.

15. У випадку некоректних вхідних даних виводиться відповідне повідомлення.

16. Перевірка помилок консольного введення може бути відсутня.

17. Використання власних глобальних змінних (крім глобальних констант для a0 і b0) НЕ
допускається.

18. Програма складається зі статичної бібліотеки (виведення інформації про виконавця)
та ще якнайменш двох одиниць трансляції.

19. Зокрема, функції обчислення f(x) і S(x) виділено в окрему одиницю трансляції, до
якої створено відповідний заголовний файл. У цьому ж заголовному файлі мають бути
значення a0 і b0.

20. За потреби можуть бути наявні й інші власні функції, крім зазначених вище.

21. Власні функції належним чином задокументовані.

22. У заголовних файлах записано ті й тільки ті оголошення, про які повинен знати
користувач відповідної бібліотеки.

23. Підключення (#include) cpp-файлів не допускається.

24. У коді відсутнє дублювання.

25. У коді відсутні «магічні константи» (неіменовані константи, що, наприклад, задають
межі a0 і b0).

26. Кожна функція (можливо, за винятком main()) має рівно один обов’язок.